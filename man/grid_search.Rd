% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/grid_search.R
\name{grid_search}
\alias{grid_search}
\title{Perform a grid search to find the most profitable parameter settings}
\usage{
grid_search(
  data,
  base_order_volume = 10,
  first_safety_order_volume = 10,
  n_safety_orders = seq(8, 16, by = 2),
  pricescale = seq(0.6, 3, by = 0.4),
  volumescale = seq(1, 2, by = 0.2),
  take_profit = seq(1, 3.5, by = 0.5),
  stepscale = seq(0.8, 1, by = 0.1),
  start_asap = T,
  stoploss = c(0, 25, 30, 40),
  compound = T,
  min_covered_deviation = 8,
  min_down_tolerance = 8,
  max_required_capital = 10000,
  n_timeperiods = 1,
  timeperiods_shift_days = 1,
  progressbar = TRUE,
  processing = "sequential",
  ncores = parallel::detectCores()
)
}
\arguments{
\item{data}{A \code{data.table} containing \code{time} and \code{price} columns, and
optionally a \code{deal_start} column.}

\item{base_order_volume}{a numeric vector of sizes of the base order (in the
quote currency)}

\item{first_safety_order_volume}{a numeric vector of sizes of the first
safety order (in the quote currency)}

\item{n_safety_orders}{a numeric vector of the maximum numbers of safety
orders}

\item{pricescale}{a numeric vector of pricescales}

\item{volumescale}{a numeric vector of volumescales (volume multipliers)}

\item{take_profit}{a numeric vector of take profit percentages}

\item{stepscale}{a numeric vector of stepscales (price deviation multipliers)}

\item{start_asap}{a logical vector indicating whether deals should start as
soon as possible}

\item{stoploss}{a numeric vector of stoploss percentages}

\item{compound}{a logical vector indicating whether to compound profits}

\item{min_covered_deviation}{the minimum percentage price deviation from the
initial order to the last safety order a given parameter combination must
cover. Parameter combinations that have a covered price deviation less than
this value are discarded and not tested.}

\item{min_down_tolerance}{the minimum price down tolerance (i.e. percentage
price deviation from the initial order price to the take profit price when
all safety orders are filled) a given parameter combination must have.
Parameter combinations that have a price down tolerance less than this
value are discarded and not tested.}

\item{max_required_capital}{the maximum capital a given parameter
constellation can require. Parameter constellations that require more
capital than this value are discarded and not tested.}

\item{n_timeperiods}{the number of timeperiods the function \code{\link[=backtest]{backtest()}}
should be applied to. Be default, \code{\link[=backtest]{backtest()}} is applied only once per
parameter constellation using the full time period of the supplied dataset.
If n_timeperiods is larger than 1, each parameter constellation is tested
with n_timeperiods. Each timeperiod starts \code{timeperiods_shift_days} later
but ends at the same time. The results are aggregated over all timeperiods
using the median. The idea behind this is to identify parameter
constellations that are more robust and potentially better generalize to
new data.}

\item{timeperiods_shift_days}{the number of days the timeperiods should be
shifted. This only has an effect if \code{n_timeperiods} is larger than 1.}

\item{progressbar}{whether to show a progressbar or not}

\item{processing}{a character string specifying the processing of the job.
Default is \code{"sequential"} which corresponds to sequential processing.
If you want to use parallel processing, set this argument to
\code{"multisession"}.}

\item{ncores}{the number of CPU cores used in parallel processing.}
}
\value{
A \code{data.frame} in which each row contains the results of one
possible combination of parameters. The rows of the returned \code{data.frame}
are ordered by the profit column.
}
\description{
This function takes possible values of martingale bot parameters and runs the
function \code{\link[=backtest]{backtest()}} with each possible combination of these values. It can
be used to quickly identify the most profitable parameter combination for a
given time period. By default, the grid search is run in parallel using all
available CPU cores.
}
\examples{
\dontrun{
# Download price data
dat <- get_binance_prices_from_csv(
  "PYRUSDT",
  start_time = "2025-01-01",
  end_time = "2025-03-01",
  progressbar = F
)

# Perform grid search
res <- grid_search(dat, progressbar = F)

# Plot the best result using purrr::exec
# First, get the single row of best parameters
best_params <- res |> dplyr::slice(1)
# Then, use exec to call backtest, splicing the parameters with !!!
exec(backtest, !!!best_params, data = dat, plot = TRUE)
}
}
