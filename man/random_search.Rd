% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/random_search.R
\name{random_search}
\alias{random_search}
\title{Perform a random search using Latin Hypercube Sampling}
\usage{
random_search(
  data,
  n_samples = 1000,
  n_safety_orders_bounds = c(8, 16),
  pricescale_bounds = c(0.6, 3),
  volumescale_bounds = c(1, 2),
  take_profit_bounds = c(1, 3.5),
  stepscale_bounds = c(0.8, 1),
  stoploss_values = c(0, 25, 30, 40),
  base_order_volume_bounds = c(10, 10),
  first_safety_order_volume_bounds = c(10, 10),
  start_asap = TRUE,
  compound = TRUE,
  min_covered_deviation = 8,
  min_down_tolerance = 8,
  max_required_capital = 10000,
  progressbar = TRUE,
  processing = "sequential",
  ncores = parallel::detectCores()
)
}
\arguments{
\item{data}{A \code{data.table} containing \code{time} and \code{price} columns, and
optionally a \code{deal_start} column.}

\item{n_samples}{The total number of random parameter combinations to test.}

\item{n_safety_orders_bounds}{A numeric vector of length 2 specifying the
min and max number of safety orders (integer values).}

\item{pricescale_bounds}{A numeric vector of length 2 for the pricescale bounds.}

\item{volumescale_bounds}{A numeric vector of length 2 for the volumescale bounds.}

\item{take_profit_bounds}{A numeric vector of length 2 for the take profit bounds.}

\item{stepscale_bounds}{A numeric vector of length 2 for the stepscale bounds.}

\item{stoploss_values}{A numeric vector of specific stoploss percentages to
sample from (e.g., \code{c(0, 25, 30, 40)}).}

\item{base_order_volume_bounds}{A numeric vector of length 2 for the base
order volume bounds. Defaults to a fixed value.}

\item{first_safety_order_volume_bounds}{A numeric vector of length 2 for the
first safety order volume bounds. Defaults to a fixed value.}

\item{start_asap}{A fixed logical value; \code{TRUE} to start deals immediately.}

\item{compound}{A fixed logical value; \code{TRUE} to compound profits.}

\item{min_covered_deviation}{A hard filter to discard combinations that do not
meet the minimum covered deviation.}

\item{min_down_tolerance}{A hard filter to discard combinations that do not
meet the minimum down tolerance.}

\item{max_required_capital}{A hard filter to discard combinations that exceed
the maximum required capital.}

\item{progressbar}{A logical value; \code{TRUE} to show a progress bar.}

\item{processing}{A character string specifying processing, either
\code{"sequential"} or \code{"multisession"}.}

\item{ncores}{The number of CPU cores for parallel processing.}
}
\value{
A \code{tibble} where each row contains the results of one parameter
combination, ordered by profit.
}
\description{
This function generates a set of random parameter combinations using Latin
Hypercube Sampling to efficiently explore the parameter space. It then runs
the \code{\link[=backtest]{backtest()}} function for each combination to find profitable settings.
This can be more efficient than a grid search when dealing with a large number
of parameters.
}
\examples{
\dontrun{
# Download price data
dat <- get_binance_prices_from_csv(
  "PYRUSDT",
  start_time = "2025-01-01",
  end_time = "2025-03-01",
  progressbar = F
)

# Perform random search
res <- random_search(dat, n_samples = 100, progressbar = F)

# Plot the best result
res \%>\%
  slice_max(profit, n = 1) \%>\%
  exec(backtest, !!!., data = dat, plot = TRUE)
}
}
